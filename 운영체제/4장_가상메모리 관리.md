### 블록 사상

블록 크기가 크면 클수록 사상 정보(논리,물리적 주소 매핑 정보)를 기억하는 데 필요한 주기억장치의 양은 작아짐. 오버페드 낮아짐. 그러나 보조기억장치와 주기억 장치 간의 데이터 전송에 많은 시간이 걸림. 공유하는 프로세스 수 제한을 받음.

#### 페이징 : 블록을 같은 크기로 분할. 블록은 페이지

#### 세그먼테이션 : 블록을 다른 크기로 분할. 세그먼트

#### 변위 :그 항목이 속해 있는 블록과 그 블록의 시작에서부터 해당 항목까지의 변위 v=(b,d)

## 페이징

v=(p,d) -> 페이지 사상 테이블에서 페이지 p를 찾고, 페이지 p가 페이지 프레임 p'에 있음을 알아낸다. 그 후p'와 d를 더하여 주기억장치상의 실제 주소 r=p'+d를 구한다.

### 직접 사상

똑같은 크기로 나누고 순서대로 매핑. 페이지 사상 테이블에 모든 프로세스의 페이지에 대한 항목을 가지고 있어 메모리 낭비가 있음.

### 연관 사상

주기억장치보다 훨씬 빠른 접근 시간을 가진 연관기억장치에 페이지 사상 테이블 전체를 넣는 방법.
연관기억장치가 고가임.

### 연관/직접 사상

가장 최근에 사용된 페이지를 연관기억장치에 저장하고, 외 다른 필요한 페이지는 캐시의 직접사상으로 가져오는 방식.

## 페이지 크기

페이지 크기가 작을수록 보다 많은 페이지와 페이지 프레임이 존재. 페이지 테이블 크기 증가.테이블 단편화. 클수록 한번에 페이지를 이동함으로 입출력 전송이 낮아져서 빠름.

페이지 크기가 작을수록 작업세트를 확보. 구역성을 가져서 필요한 량의 정보만을 가지게 되어, 주기억 장치에 적재 시 필요한 정보만을 가진 페이지만 적재 가능.

페이지 단편화 감소.

### 페이지 인출 기법

- 요구 페이징 기법 : 요구 시 주기억 장치로 옮겨짐.
- 예상 페이징 기법 : 필요하다고 판단되는 페이지를 미리 적재.

## 세그먼테이션

페이징과 똑가이 직접사상, 연관사상, 연관/직접 사상으로 나눌 수 있다.
세그먼테이션 단점 : 세그먼트 크기가 지나치게 커서 주기억 장치에 적재할 수 없는 경우가 있음.

## 세그먼테이션/페이징 기법

- 자주 사용되는 페이지는 연관 기억 장치에 저장.
- 세그먼트 가변적 길이로 자른 세그먼트 사상 테이블 참조
- 세그먼트 페이지 내 또 페이지 사상 테이블을 참조

## 페이지 교체 알고리즘

- FIFO : 순서대로 적재하고 순서대로 변경
- 최적 교체 : 앞으로 가장 오랫동안 사용하지 않을 페이지와 교체. 모든 상황을 사전에 파악해야 함.
- LRU : 현 시점에서 가장 오래 전에 사용된 페이지와 교체. 각 페이지 마다 타임-스탬프용 카운터나 스택으로 감시.
- 2차 기회 알고리즘 : 기본적으로 FIFO 알고리즘. 적재된 페이지들을 참조 비트 0으로 세팅. 참조하면 참조비트 1로 변경. 변경될 순서에서 참조비트 1이면 0으로 변경 후 그 다음 녀석을 변경하도록 함.
- LFU : 참조 횟수가 제일 적은 페이지를 교체. 이는 처음에 많이 사용되다가 나중에 사용되지 않은 페이지가 계속 메모리에 남게 되는 모순이 있음.
- MFU : 가작 작은 참조 횟수를 가진 페이지가 참조되면, 앞으로 사용될 것이라는 판단 하에 적재

## 스래싱

페이지 부재가 계속 발생하여 페이지 수행 시간보다 교체시간이 더 많아지는 현상

## 구역성

참조했던 부분을 집중적으로 참조할 것이다.

- 시간 구역성: 최근에 참조된 기억장소가 가까운 시간 내에 계속 참조될 가능성이 높다.
- 공간 구역성 : 참조된 기억장소의 근처의 기억자송를 계속 참조할 가능성이 높다.

## 작업세트

자주 참조되는 페이지들의 집합체. 주기억 장치 내 작업세트 공간이 존재하면 더 효율적으로 처리할 수 있다.

## 페이지 부재율

페이지 부재율이 높으면, 더 많은 프레임이 필요.

페이지 부재율이 낮으면,, 너무 많은 프레임을 가지고 있음을 뜻함.

# 병행 제어

둘 이상의 트랜잭션이 동시에 접속하여 연산 수행할 떄, 문제점이 전혀 발생하지 않도록 트랜잭션의 수행을 제어함.

데이터베이스의 공용도 업, 응답시간 최소화, 시스템 활용도 업.

동시에 동일한 내용을 접근하려고 하는 것이 아니라면, 동시 수행 가능.

## 무제어 병행 수행의 문제점

- 갱신 분실 : 엎어씀
- 모순성 : 기대하던 값과 다름.
- 연쇄 복귀: 롤백 중, 다른 트랜잭션에서 데이터를 읽어서 잘못된 데이터를 가져다 씀.

## 트랜잭션 스케줄

연산들의 실행 순서. 인터리빙 방식을 위해 실행 순서 지정.

#### 직렬 스케줄

연산을 모두 순차적으로 실행함.

- cpu 활용도 떨어짐.
- 항상 정확한 값 산출

#### 비직렬 스케줄

순서와 상관없이 병행 수행.

- 정확성 보장 못함.

#### 직렬 가능 스케줄

비직렬 스케줄이 정확한 결과를 산출하기 위해, 직렬 스케줄과 동등한 비직렬 스케줄을 말함.

- 만약 두 개의 트랜잭션이 read 연산만 수행하면, 연산 순서가 중요하지 않고 상호 간섭이 없음.
- 만약 두 개의 트랜잭션이 같은 데이터 항목에 접근하지 않는다면, 상호 간섭이 발생하지 않고 순서 중요하지 않음.
- 어떠한 같은 데이터 항목에 한 트랜잭션이라도 write를 하면, 실행 순서가 중요한다.

직렬 가능성을 검사하지 않고, 직렬 가능성을 보장하는 병행 제어 기법을 사용..

## 병행 제어 기법

### 로킹

- 사용중인 데이터에 lock을 건다.
  - 공용 lock(shared-lock) : 접근하는 것이 읽기 일 시, 다른 트랜젝션도 읽기로만 접근 가능.
  - 전용 lock(exclusive-lock) : 접근이 write이면, 다른 트랜젝션은 어떤것도 못함.

로킹 단위 : lock을 거는 대상. DB 전체가 될 수도 있고, 릴레이션, 튜블, 속성이 될 수도 있음.

단위가 작아질수록: 구현 복잡. 병행성이 높아짐. 로크 수가 많음. 병행 제어 기법이 복잡.
단위가 커질수록: 구현이 용이. 병행성이 낮아짐. 로크 수가 적음. 병행 제어 기법이 간단.

## 2단계 로킹 규약

직렬 가능성을 보장받을 수 있는 규약.

1. 확장 단계
2. 축소 단계

## 교착 상태

2단계 로킹 규약은 직렬 가능성 보장, 반면에 교착 상태 문제 내포.
서로 상대가 가지고 있는 데이터 항목을 코그가 해제되기만을 기다려서 무한정 로딩.

교착상태 해결 방법 : 회피, 예방, 탐지.

회피 : 자원 할당할 때 ,교착상태가 일어날지 실시간 확인. 타임스탬프 순서 기법 이용.
예방 : 트랜잭션을 실행시키기 전에 교착상태 발생을 불가능하게 만듬.
탐지 : 교착상태가 일단 일어나면, 트랜잭션 하나를 제거함.

---

## 타임스탬프 순서 기법

시스템에서 생성하는 고유 번호인 타임스탬프를 트랜잭션에 부여하여 실행. 직렬 스케줄의 결과와 항상 같도록 보장.

1. 논리적 계수기 : 트랜잭션이 시스템에 들어올 때마다, 숫자를 하나씩 증가시켜 트랜잭션의 타임스탬프 값으로 부여하는 것.
2. 시스템 클록: 트랜잭션이 시스템이 들어오면 시스템 클록의 값을 그 트랜잭션의 타임스탬프 값으로 부여.

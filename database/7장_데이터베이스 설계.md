# 데이터베이스 설계

## 데이터베이스 설계 개념

현실 세계를 컴퓨터 세계의 데이터로 변환하기 위한 데이터베이스 모델링 과정.
현실세계, 개념세계, 컴퓨터 세계.

## 1-1 데이터베이스 생명 주기

1. 요구 조건 분석
2. 설계
3. 구현
4. 운영
5. 감시 및 개선

## 1-2 데이터베이스 설계단계

1. 요구 조건 분석
2. 개념적 설계 : 개념 스키마, 트랜잭션 모델링, E-R모델
3. 논리적 설계 : 목표 DBMS에 맞는 스키마 설계
4. 물리적 설계 : 목표 DBMS에 맞는 물리적 구조의 데이터로 변환
5. 구현 : 특정 DBMS의 DDL로 데이터베이스 생성

## 개념적 설계

ER관계 표시.

엔티티 도출, 관계 표시

## 논리적 설계

## 물리적 설계

#### 고려 사항

1. 응답 시간 최소화
2. 저장 공간의 효율화
3. 트랜잭션 처리도(처리 능력)

#### 인덱스 활용

자료 검색 방법

- FTS(full table scan) : 전체 탐색
- 인덱스 스캔 방법

## 인덱스

#### 논리적 구분에 따른 인덱스

- 단일 칼럼 인덱스 : 한 개의 칼럼으로 생성된 인덱스.
- 결합 인덱스 : 두 개 이상의 칼럼으로 생성된 인덱스. 일반적으로 10개 이하의 칼럼 조합으로 생성.

- 유니크 인덱스 : 모든 유니크 및 기본키 제약조건 생성 시 자동으로 유니크 인덱스가 생성.
- 논 유니크 : 논 유니크 인덱스 대상 칼럼은 중복된 값을 가질 수 있다.

- 함수 기반 인덱스 : 인덱스에 포함된 1개 이상의 칼럼이 함수 또는 수식을 사용하여 생성된 경우를 말함. B-tree, Bitmap Index

#### 물리적 구분에 따른 인덱스

- B-tree 구조 인덱스 : 일반적으로 생성되는 인덱스. 큰 분포도를 갖는 테이블에 적합. 비교적 키의 갱신 비용이 적다. OR 사용 쿼리에 비효율적.

- 비트맵 인덱스 : 컴퓨터 최소단위인 비트를 이용해서 칼럼 값을 저장, ROW ID를 자동으로 생성하는 인덱스. 비트 연산 수행. 적은 분포도를 갖는 테이블에 적합. 갱신 비용이 매우 큼. OR 사용 쿼리문에 효율적.

- 클러스터형 인덱스 : 테이블에 한 개만 생성 가능. 논리적으로 관련된 데이터를 물리적으로 디스크 상에 인접시켜 저장. 관련된 데이터가 일반적으로 동시에 함께 사용.

경우에 따라 인덱스 재구축을 할 필요가 있음.

1. 존재하는 인덱스를 다른 테이블 스페이스로 옮길 필요가 있는 경우
2. 테이블과 인덱스가 같은 테이블스페이스에 존재하거나 객체를 디스크로부터 분산시킬 필요가 있는 경우
3. 삭제된 테이블의 행이 많아 인덱스의 저장공간이 반환되지 않고 사용할 수 없는 공간으로 남아 있는 경우

## 역정규화

지나친 정규화로 인해 시스템의 성능을 저하시킬 때 사용.
정규화가 너무 지나치게 최소 단위로 분해되면, 조인하는 데에 성능이 많이 들어감.

1. 칼럼 역정규화(데이터의 중복)
2. 테이블 분리 : 테이블 분리 기준은, 한 칼럼의 데이터 크기가 너무 큰 경우.
3. 테이블 통합
4. 요약 테이블 생성
